#' Quantile normalization of a non-UMI read counts matrix
#'
#' Normalizes read counts (without UMIs) such as those generated by smart-seq2
#' to match a discrete quasi-UMI target distribution. The resulting QUMI counts
#' can be analyzed as if they were UMI counts.
#'
#' @param m A SingleCellExperiment, matrix or sparse Matrix of non-negative
#' integers (count data).
#' @param assayName In case m is a SingleCellExperiment, the assay from which
#'   the quasi-UMIs should be calculated is specified here. NB! The default,
#'   "TPM" for transcripts per million does refer to such values after
#'   summarizing to gene level. The algorithm in its current form has not been
#'   evaluated for quasi-UMI generation from transcript counts, as full-length
#'   data with UMIs has not until very recently been available.
#' @param shape Positive scalar, a fixed shape parameter for the target
#'   distribution. The shape parameter represents sigma, tail, and size for the
#'   Poisson-lognormal, Poisson-Lomax, and negative binomial target
#'   distributions, respectively. See \code{\link[sads]{dpoilog}},
#'   \code{\link{dnblomax}}, or \code{\link[stats]{dnbinom}}.
#' @param lik likelihood of target distribution, either Poisson-lognormal
#'   ("poilog"), Poisson-Lomax ("plomax"), or negative binomial ("nb").
#' @param quadpts positive integer, number of quadrature points. Increase for
#'   greater precision but slower computation.
#'
#' @return An object of same class as m but with the nonzero values normalized
#' to match the target quasi-UMI distribution. In case of a
#' SingleCellExperiment, the quasiUMI is added to a new asays slot named qumi.
#' @examples
#' #First import a SingleCellExperiment
#' library(scRNAseq)
#' library(SingleCellExperiment)
#' sce <- ReprocessedAllenData("tophat_counts")
#' tpm(sce) <- assay(sce, "tophat_counts")
#'
#' #Then run the function
#' sce <- quminorm(sce[,seq_len(10)])
#'
#' @export quminorm
quminorm <-function(m, assayName = "tpm", shape = 2,
                    lik=c("poilog","plomax","nb"), quadpts=1000){
    #m a matrix with samples in the columns
    #returns a matrix of same dims that has been quantile normalized
    #shape should be a scalar
    #... additional args such as quadpts passed to quminorm functions
    if(inherits(m, "SingleCellExperiment")){
        fullM <- m
        m <- assay(m, assayName)
    }
    lik<-match.arg(lik)
    qfunc<-switch(lik,poilog=quminorm_poilog,plomax=quminorm_plomax,nb=quminorm_nb)
    res<-0*m
    for(i in seq_len(ncol(m))){
        res[,i]<-qfunc(m[,i],shape,quadpts=quadpts)
        message(paste0("Column ", i," of ", ncol(m), " processed"))
    }

    if(missing(fullM) == FALSE){
        prevAssayNames <- assayNames(fullM)
        assay(fullM, length(assays(fullM))+1) <- res
        assayNames(fullM) <- c(prevAssayNames, "qumi")
        return(fullM)
    } else {
        res
    }

}
