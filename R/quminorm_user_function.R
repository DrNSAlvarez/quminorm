#' Quantile normalization of a non-UMI read counts matrix
#'
#' Normalizes read counts (without UMIs) such as those generated by smart-seq2
#' to match a discrete quasi-UMI target distribution. The resulting QUMI counts
#' can be analyzed as if they were UMI counts.
#'
#' @param m A SingleCellExperiment, matrix or sparse Matrix of non-negative
#' integers (count data).
#' @param assayName In case m is a SingleCellExperiment, the assay from which
#'   the quasi-UMIs should be calculated is specified here. NB! The default,
#'   "TPM" for transcripts per million does refer to such values after
#'   summarizing to gene level. The algorithm in its current form has not been
#'   evaluated for quasi-UMI generation from transcript counts, as full-length
#'   data with UMIs has not until very recently been available.
#' @param shape Positive scalar, a fixed shape parameter for the target
#'   distribution. The shape parameter represents sigma for the
#'   Poisson-lognormal target distribution. See \code{\link[sads]{dpoilog}}.
#'
#' @return An object of same class as m but with the nonzero values normalized
#' to match the target quasi-UMI distribution. In case of a
#' SingleCellExperiment, the quasiUMI is added to a new assays slot named qumi.
#' @examples
#' #First import a SingleCellExperiment
#' library(scRNAseq)
#' library(SingleCellExperiment)
#' sce <- ReprocessedAllenData("tophat_counts")
#' tpm(sce) <- assay(sce, "tophat_counts")
#'
#' #Then run the function
#' sce <- quminorm(sce[,seq_len(10)])
#'
#' @importFrom SummarizedExperiment assay assayNames assay<- assays assayNames<-
#' @export quminorm
quminorm <-function(m, assayName = "tpm", shape = 2){
    #m a matrix with samples in the columns
    #returns a matrix of same dims that has been quantile normalized
    #shape should be a scalar
    #... additional args such as quadpts passed to quminorm functions

    if(inherits(m, "SingleCellExperiment")){
        fullM <- m
        m <- assay(m, assayName)
        sce <- TRUE
    } else {sce <- FALSE}
    res<-0*m
    for(i in seq_len(ncol(m))){
        res[,i]<-quminorm_poilog(m[,i],shape)
        message(paste0("Column ", i," of ", ncol(m), " processed"))
    }
    if(sce){
        prevAssayNames <- assayNames(fullM)
        assay(fullM, length(assays(fullM))+1) <- res
        assayNames(fullM) <- c(prevAssayNames, "qumi")
        return(fullM)
    } else {
        res
    }
}
